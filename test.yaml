# Before continuing with the storage specification: it's possible to use a PodPreset to accomplish the shared volume mount,
# however, it's in alpha state, and to activate this, it's a headache depending on the k8s environment we're working on.
# That's the reason I decided to use the more "traditional" PersistentVolume and PersistentVolumeClaim to share a volume
# across all pods.
# The advantage of PodPreset over defined volumes is that isn't necessary to set a storage capacity and claiming then, and
# the way it works is like a template or the more well-known inheritance in object-oriented programming languages, defining
# the local volume on that preset and then being used by all the pods which have been referenced.
---
apiVersion: v1 # https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/
kind: PersistentVolume
metadata:
  name: shared-volume
  labels:
    type: local
spec:
  storageClassName: manual
  capacity:
    storage: 100Mi # I'm forced to do this
  accessModes:
    - ReadWriteOnce # ReadOnlyMany seems to be unsupported on HostPath volume plugin
  hostPath:
    path: /path/to/product-warehouse-manager-aos
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: shared-claim
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Mi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: logging-api
spec:
  selector:
    matchLabels:
      app: logging-api
  replicas: 1
  template:
    metadata:
      labels:
        app: logging-api
    spec:
      containers:
        - name: logging-api
          image: maanuelmm/prism:tini
          args:
            - "mock -d -h 0.0.0.0 /app/openapi.yaml"
          volumeMounts:
            - mountPath: /app
              name: logging-api-spec
              subPath: app/logging-api/specification
              readOnly: true
          ports:
            - containerPort: 4010
      volumes:
        - name: logging-api-spec
          persistentVolumeClaim:
            claimName: shared-claim
---
apiVersion: v1
kind: Service
metadata:
  name: logging-api
  labels:
    app: logging-api
spec:
  ports:
    - name: "logging-api"
      port: 80
      targetPort: 4010
  selector:
    app: logging-api
---
apiVersion: apps/v1
kind: Deployment # maybe ReplicaSet is possible, but idk
metadata:
  name: swagger-ui
spec:
  selector:
    matchLabels:
      app: swagger-ui
      #role: master
      #tier: backend
  replicas: 1
  template:
    metadata:
      labels:
        app: swagger-ui
        #role: master
        #tier: backend
    spec:
      containers:
        - name: swagger-ui
          image: swaggerapi/swagger-ui:v3.25.2
          env:
            - name: URLS
              value: '[{url:"/app/logging-api/specification/openapi.yaml",name:"Logging API"},{url:"/app/products-api/specification/openapi.yaml",name:"Products API"},{url:"/app/invoicing-api/specification/openapi.yaml",name:"Invoicing API"},{url:"/app/orders-api/specification/openapi.json",name:"Orders API"}]'
          volumeMounts:
            - mountPath: /usr/share/nginx/html/app
              name: swagger-ui-specs
              subPath: app
              readOnly: true
          ports:
            - containerPort: 8080
      #restartPolicy: OnFailure # seems to be unsupported on Deployment (only Always is the supported value regarding being supported on Pod)
      volumes: # https://kubernetes.io/docs/concepts/storage/volumes/#hostpath
        - name: swagger-ui-specs
          persistentVolumeClaim:
            claimName: shared-claim
          #hostPath:
            # directory location on host
            #path: /home/manuel/Documents/vscode-workspace/product-warehouse-manager-aos/app
            # this field is optional
            #type: Directory
---
apiVersion: v1
kind: Service
metadata:
  name: swagger-ui
  labels:
    app: swagger-ui
spec:
  #type: LoadBalancer # (or even NodePort). More info: http://alesnosek.com/blog/2017/02/14/accessing-kubernetes-pods-from-outside-of-the-cluster/ https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/ https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/
  ports:
    - name: "http"
      port: 80
      targetPort: 8080
  selector:
    app: swagger-ui
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress # https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers https://stackoverflow.com/questions/51511547/empty-address-kubernetes-ingress
metadata:
  name: shit-happens
spec:
  rules:
    - host: swagger.localhost
      http:
        paths:
          - backend:
              serviceName: swagger-ui
              servicePort: 80
    - host: api.localhost
      http:
        paths:
          - path: /events
            backend:
              serviceName: logging-api
              servicePort: 80
